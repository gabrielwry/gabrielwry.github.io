<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1 maximum-scale=1; minimum-scale=1; user-scalable=no;"> <meta content="System Programming Note" name="description"> <meta name="keywords" content="UNIX,School,Note,blog"> <meta name="author" content="GabrielWang"> <meta name="baseurl" content=""> <title> Gabriel Wang|System Programming </title> <!-- favicon --> <link rel="shortcut icon" href="/static/assets/img/favicon.ico"> <!-- Main CSS --> <link href="/static/assets/app-20180125.min.css" rel="stylesheet"> <link href="/static/css/custom.css" rel="stylesheet"> <!-- Main Scripts --> <script src="/static/assets/app-20180125.min.js"></script> <script src="/static/assets/blog-20180125.min.js"></script> <!-- Google AdSense --> <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script> <script> (adsbygoogle = window.adsbygoogle || []).push({ google_ad_client: "ca-pub-6196184668650108", enable_page_level_ads: true }); </script> </head> <body id="page-top" class="landing-page"> <div class="search-tool" style="position: fixed; top: 0px ; bottom: 0px; left: 0px; right: 0px; opacity: 0.95; background-color: #111111; z-index: 9999; display: none;"> <input type="text" class="form-control search-content" id="search-content" style="position: fixed; top: 60px" placeholder="Search Blog"> <div style="position: fixed; top: 16px; right: 16px; z-index: 9999;"> <img src="/static/assets/img/search/cb-close.png" id="close-btn"/> </div> </div> <div style="position: fixed; right: 16px; bottom: 20px; z-index: 9999;"> <img src="/static/assets/img/search/cb-search.png" id="search-btn" title="Double click Ctrl"/> </div> <div class="navbar-wrapper"> <nav class="navbar navbar-default navbar-fixed-top" role="navigation"> <div class="container"> <div class="navbar-header page-scroll"> <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button> <a class="navbar-brand" href="/">Gabriel Wang</a> </div> <div id="navbar" class="navbar-collapse collapse"> <ul class="nav navbar-nav navbar-right"> <li><a class="page-scroll" href="blog/"></a></li> <li> <a class="page-scroll" href="/blog/">Blog</a></li> <li> <a class="page-scroll" href="/datascience/">Data Science</a></li> <li> <a class="page-scroll" href="/life/">Life</a></li> <li> <a class="page-scroll" href="/school/">School</a></li> </ul> </div> </div> </nav> </div> <div class="wrapper wrapper-content animated fadeInRight article"> <div class="row"> <div class="col-lg-10 col-lg-offset-1"> <div class="ibox"> <div class="ibox-content"> <div class="pull-right"> <a class="btn btn-white btn-xs" href="/school">School</a> </div> <div class="text-center article-title"> <span class="text-muted"><i class="fa fa-clock-o"></i> 21 May 2017</span> <h1> System Programming </h1> </div> <h1 id="system-programming-final-review">System Programming Final Review</h1> <h2 id="summary">Summary:</h2> <p>This write up will summarize and categorize important knowledge about system programming from the text book <em>Advanced Unix Programming 2nd Edition</em> and the notes from the class CS450 offered by Emory Computer Science Department, taught by Professor Ken Mandelberg, who constantly sighed during the lectures. Note this is for my own study and usage.</p> <h2 id="final-exam-range">Final Exam Range:</h2> <ul> <li>Ch1. 1-1.4,1.7</li> <li>Ch2. ALL</li> <li>CH3. 3.9.1 only in 3.9, and everything else</li> <li>Ch5. Thru 5.13</li> <li>Ch6. 6.1-6.4 (easy on 6.3)</li> <li>Ch7. 7.1-7.2, 7.4, 7.5.1, 7.5.2, 7.8, 7.9, 7.12, 7.13.1, 7.13.2</li> <li>Ch9. 9.1 - 9.1.6, 9.1.9, 9.1.10, 9.4, 9.6, 9.7.1, 9.7.2</li> </ul> <h2 id="content">Content:</h2> <ul> <li><a href="#c-and-unix">C and UNIX</a></li> <li><a href="#file-io">File I/O</a></li> <li><a href="#process-and-threads">Process and Threads</a></li> <li><a href="#interprocess-communication">Interprocess Comunication</a></li> </ul> <h2 id="codes">Codes:</h2> <ul> <li><a href="https://github.com/gabrielwry/System-Programming/tree/master/HW1">Goldbach test with Sieve Method</a></li> <li><a href="https://github.com/gabrielwry/System-Programming/tree/master/HW2">Archive program to do similar <code class="highlighter-rouge">ar</code> as system call</a></li> <li><a href="https://github.com/gabrielwry/System-Programming/tree/master/HW3">Uniqify and sort words from <code class="highlighter-rouge">stdin</code></a></li> <li><a href="https://github.com/gabrielwry/System-Programming/tree/master/HW4">Interprocess communication programs to compute perfect numbers</a></li> </ul> <h3 id="-c-and-unix"><span name="c-and-unix"> C and Unix</span></h3> <ul> <li>UNIX versions and standards: <ul> <li>UNIX was first developed as a research project in AT&amp;T Bell Lab</li> <li>Licenses of UNIX make their own modification. <strong>BSD</strong>, developed by Berkeley University supports <strong>sockets</strong> and <strong>virtual memory.</strong></li> <li>UNIX world divides to <strong>BSD</strong> side and <strong>System V side</strong>.</li> <li><strong>POSIX</strong> is a standard for UNIX system call and commands from IEEE.</li> <li>If an application conforms the <strong>standard</strong> and the <strong>language</strong> (<code class="highlighter-rouge">C, C++</code>) it is written in, the application’s source code is portable and can be compiled and run with no changes.</li> <li>Three principal strains of UNIX: <ul> <li>Closed commercial systems;</li> <li>BSD-based open source systems;</li> <li>Linux;</li> </ul> </li> </ul> </li> <li>System Calls <ul> <li>C and C++ Bindings: <ul> <li>A system call execute some special codes that transfers control from user to kernel and back, and hence it is <strong>expensive</strong></li> <li>Every system call is defined inside the <strong>header</strong> file, which can have conflicts due the implementation of the OS version, so sometimes a header file needs to be adjusted to work properly.</li> <li>Other languages also have standard facilities to support some POSIX facilities.</li> <li>Several tips for system call usages: <ul> <li>include header (废话);</li> <li>do error handling, maybe use <code class="highlighter-rouge">perror</code> really convenient;</li> <li><code class="highlighter-rouge">cast</code> is not very safe, it will suppress compiler warning if the types don’t match;</li> <li>check if call is thread safe;</li> <li>write standardized, so your program is portable;</li> </ul> </li> <li>Read the man page for function syntax and synopses.</li> </ul> </li> <li>Error Handling : <ul> <li>always check for error, most likely the call will return <code class="highlighter-rouge">-1</code> for error, and it will set the <code class="highlighter-rouge">errno</code>;</li> <li>There are system calls’s errors depends on changing <code class="highlighter-rouge">errno</code></li> <li>There is a <code class="highlighter-rouge">strerror()</code> call inside <code class="highlighter-rouge">&lt;error.h&gt;</code> that will translate the <code class="highlighter-rouge">errno</code> to understandable string.</li> <li>error macro is a gadget of codes that handle error checking for us, like <code class="highlighter-rouge">EC_CLEANUP_BGN</code> and <code class="highlighter-rouge">EC_CLEANUP_END</code></li> </ul> </li> </ul> </li> <li>Date and Times <ul> <li>Calendar time: used to log information about access, modification or status change times of a file. <ul> <li>Four types: , <ol> <li>arithmetic type <em>time_t</em> seconds since epoch, midnight , Jan 1st, 1970, always implemented as a <em>long 32-bit signed int</em>;</li> <li>struct type <em>timeval</em> time in seconds and millisec;</li> <li>struct type <em>tm</em>, breaks down to year, moth, day, hour, minute, sec</li> <li>string, like <em>Tue Jul 23 09:44:17 2002</em>;</li> </ol> </li> </ul> </li> <li>Execution time: used for tracking process execution. <ul> <li>Main types: <ul> <li>long type <em>clock_t</em>, time interval in units of <strong>CLOCKS_PER_SEC</strong></li> <li>struct type <em>timeval</em> holds an interval in seconds and microseconds</li> <li>struct type <em>timespec</em> holds interval in seconds and nanoseconds.</li> </ul> </li> </ul> </li> </ul> </li> </ul> <h3 id="file-io"><span name="file-io">File I/O</span></h3> <ul> <li> <p>File System:</p> <ul> <li>The block I/O system is accessed via a block special file, or block device that interfaces directly with the disk; <ul> <li>Disk can be dived to different volume, partition, or file system.</li> <li>Buffer cache can be performed on block Disk Device but not Raw Disk Device; dir, files, and i-nodes are not supported for either device.</li> </ul> </li> <li><code class="highlighter-rouge">statvfs() and fstatvfs()</code>: get file system information by path or by fd</li> <li>Mounting and unmounting file system: connecting to a disk device to the hierarchy tree started with root is called mounting, and disconnecting is called unmounting. <ul> <li>need device name and the intended directory to mount a file system, original content of the directory is now hided, will reappear when the device is unmounted</li> </ul> </li> <li>Hard link and Symbolic link: <ul> <li>hard link: an entry in a directory with a name and an i-number <ul> <li>create: can get a hard link when any types of file is created (including dir), and can get additional hard link to nondirectories with <code class="highlighter-rouge">link()</code> with oldpath and newpath, the two pathes are equivalent in anyway. The second new link must not be existed already, or otherwise need to unlink first.</li> <li>rename: use <code class="highlighter-rouge">mv</code> command, but won’t deal with link to another file system <ul> <li><code class="highlighter-rouge">rename()</code> system call: if new path exists, remove it with unlink or rmdir, link oldpath with new path even if the old path is a dir, remove the oldpath with unlink or rmdir</li> <li>Note that, new path and old path have to be either both dir or both files, if new path is dir, it has to be empty, you need write permission in new path’s parent, if rename fails, everything left unchanged</li> </ul> </li> </ul> </li> <li>symbolic link: symbolic links put path of file to be linked to in the data part of an actual file, no read or write but use system calls, symbolic link will recursively point to next link until something that is not a symbolic link is reached. <ul> <li>create: <code class="highlighter-rouge">symlink()</code> system call to make symbolic link, works like <code class="highlighter-rouge">link()</code>, but make a hard link to a symbolic link file that contain the string given by new path</li> <li>read: <code class="highlighter-rouge">readlink()</code></li> </ul> </li> </ul> </li> <li>Accessing and Displaying File Metadata: <ul> <li><code class="highlighter-rouge">stat() lstat() fstat()</code>: <code class="highlighter-rouge">stat</code> get file info by path, <code class="highlighter-rouge">lstat</code> get file info by path without following symbolic link, <code class="highlighter-rouge">fstat</code> get file info by file descriptor; <code class="highlighter-rouge">lstat</code> will display the metadata file of the symbolic link, if reached one.</li> </ul> </li> <li>Directory: UNIX implemented directory as a regular file, except a special bit is set in i-node and kernel does not permit writing on it. <ul> <li>Read: <code class="highlighter-rouge">opendir()</code> return dir pointer followed by the path <code class="highlighter-rouge">closedir()</code> close the dir pointed by the dirp pointer; <code class="highlighter-rouge">readdir()</code> read the dir pointed by the pointer returned from <code class="highlighter-rouge">opendir()</code> to the structure <code class="highlighter-rouge">dirent</code> which has i-number and name. <code class="highlighter-rouge">rewinddir()</code> can read it again without <code class="highlighter-rouge">close</code> and <code class="highlighter-rouge">reopen</code> it. Use <code class="highlighter-rouge">readdir_r()</code> to supply a memory to read the info into and supports multi threads.</li> <li><code class="highlighter-rouge">chdir() fchdir()</code> system call behind <code class="highlighter-rouge">cd</code> command, change directory by path or by file descriptor.</li> <li><code class="highlighter-rouge">mkdir() rmdir()</code> <ul> <li><code class="highlighter-rouge">mkdir()</code> automatically creates the . and .. dir</li> <li><code class="highlighter-rouge">rmdir()</code> has to remove non-empty dir, or multiple unlink are needed first.</li> </ul> </li> </ul> </li> <li>Changin I-Node: <ul> <li><code class="highlighter-rouge">chmod() fchmod()</code>: can change a file’s S_ISUID, S_ISGID, S_ISVTX and permission</li> <li><code class="highlighter-rouge">chown() fchown() lchown()</code>: change owner and group of a file by path or by fd, of regular file or symbolic link file.</li> <li><code class="highlighter-rouge">utime()</code> set file access time with struct <code class="highlighter-rouge">utimbuf</code></li> </ul> </li> </ul> </li> <li> <p>File types:</p> <ul> <li> <p>Ordinary File: segment of bytes</p> <ul> <li>The structure of a disk:</li> </ul> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	 |   Boot Block  |    
	 ===============
	 |   Super Block |  &lt;- Stores parameters of size
	 ===============
	 |   I-nodes     | &lt;- Meta data for a file (length, permission, group owner, time stamp, type, block list
	 ===============
	 |               |
	 ===============
	 |       DATA    |
    
</code></pre></div> </div> <ul> <li>Directories: has an i-node itself, using a 2-column to keep name -&gt; i-node <ul> <li>Relative path name starts with the current dir, absolute path starts with the root dir (usually i-node 2, stored when kernel is first constructed)</li> <li></li> </ul> </li> </ul> </li> </ul> </li> <li> <p>File Descriptor and Open File Description</p> <ul> <li>File Descriptor: <ul> <li>total: 1 - N, 0 is reserved for <code class="highlighter-rouge">stdin</code>, 1 is for <code class="highlighter-rouge">stdout</code>, 2 is for <code class="highlighter-rouge">stderr</code></li> <li>UNIX filter read from <code class="highlighter-rouge">STDIN_FILENO</code> and write to <code class="highlighter-rouge">STDOUT_FILENO</code> so the shell can use it in pipeline.</li> <li>can be used for any types of file</li> <li><code class="highlighter-rouge">open()</code> for files with regular file, special files, and FIFO, <code class="highlighter-rouge">pipe()</code> to open un-named pipes;</li> </ul> </li> <li>Open File Description: <ul> <li>file descriptor is just a pre-process table entry which will point to a file-table entry, Open File Description and then point to the data via <strong>i-node</strong></li> <li>multiple file descriptors can point to the same file description</li> <li>each <code class="highlighter-rouge">open</code> and <code class="highlighter-rouge">pipe</code> call creates a new <strong>file descriptor</strong> and a <strong>file description</strong></li> <li>duplication of file descriptor will point to the same file description. (<code class="highlighter-rouge">dup,dup2,fork</code> system calls)</li> </ul> </li> <li>Permission: <ul> <li>9 permissions in total: read,write,execute for owner, group and others</li> <li>Use bit operation <code class="highlighter-rouge">|</code> to set permission mask</li> </ul> </li> </ul> </li> <li> <p><code class="highlighter-rouge">open</code> and <code class="highlighter-rouge">create</code> system call</p> <ul> <li><code class="highlighter-rouge">open</code> open an existing file, or create one (can only be regular file), and return a file descriptor which can be later used. <ul> <li>Existing File: specified by <code class="highlighter-rouge">path</code>, use flags <code class="highlighter-rouge">O_RDONLY O_WRONLY O_RDWR</code>, <code class="highlighter-rouge">PERM</code> arguments are always omitted for existing files; <ul> <li>file offsets is where <code class="highlighter-rouge">read</code> and <code class="highlighter-rouge">write</code> will occur and is placed at the first byte of the file</li> <li>files descriptor returned is the lowest number available.</li> </ul> </li> </ul> </li> <li>Creating File: need O_CREAT flag, <code class="highlighter-rouge">PERM</code> is used to set the file’s permission <ul> <li>O_TRUNC can make a fresh clean file with no data in it, if the process have right permission <ul> <li>new file will need write permission in parent directory, existing files only care about permission on the file itself</li> <li><code class="highlighter-rouge">create</code> system call to take care of the combination of flags</li> <li>Ownership: <ul> <li>owner set to effective user-ID of the process</li> <li>group is set to either groupID of the parent directory or the effective group-ID of the process</li> </ul> </li> <li>O_EXCL returns error if exists.</li> </ul> </li> <li>Using file as a lock: <ul> <li>For exclusive access to resource: try open a file with O_EXCL when trying to access resources, only one process will succeed, when that one process finished, it will unlink the file and other process can succeed on access theh resource.</li> </ul> </li> </ul> </li> </ul> </li> <li> <p><code class="highlighter-rouge">Unmask</code> and <code class="highlighter-rouge">unlink</code></p> <ul> <li><code class="highlighter-rouge">unmask()</code> is used to change the permission group 9-bit, it will return the old mask</li> <li><code class="highlighter-rouge">unlink()</code> reduces the link number in i-node by one, if the count reach 0, the file system will discard the file. <ul> <li>Note: if a process that has this file open is not closed yet, the actual file data will remain on the disk but the file name will be removed once the count reached 0.</li> <li>Any kind of file can be unlinked, but only superuser can unlink a dir, always use rmdir a directory.</li> </ul> </li> </ul> </li> <li> <p>Temporary Files: mkstemp guarantees to create a file with unique name, need to arrange <code class="highlighter-rouge">unlink()</code></p> </li> <li> <p>File offset and O_APPEND:</p> <ul> <li>A file offset is a position in regular file where next <code class="highlighter-rouge">read</code> or <code class="highlighter-rouge">write</code> will occur</li> <li>Independent offset each time a file is opened, as the file description is unique.</li> <li>Without the O_APPEND, the offset starts at zero, and unless specified, the <code class="highlighter-rouge">read</code> and <code class="highlighter-rouge">write</code> are sequential.</li> <li>O_APPEND will prevent from overwriting data, good for logging (setting offset of write to EOF automatically)</li> </ul> </li> <li> <p><code class="highlighter-rouge">write()</code>:</p> <ul> <li>writes nbyte to the current position pointed by offset, and increment the offset by the number of bytes written;</li> <li><code class="highlighter-rouge">write()</code> doesn’t really write data to the disk, it actually first transfers data to a buffer and then return; If UNIX crashes: <ul> <li>real data won’t be written on disk</li> <li>process won’t be notified about the error, partial write won’t trigger the errno</li> <li>the order of the physical write can not be controlled</li> </ul> </li> </ul> </li> <li> <p><code class="highlighter-rouge">read()</code>: read n-bytes from the current position specified by the offset, won’t be affected by the O_APPEND, partial read won’t trigger the errno.</p> </li> <li> <p><code class="highlighter-rouge">close()</code> only mark the file descriptor as reusable, when the last file descriptor pointed to a open file description is closed, the open file description closed as well ( the file description keeps the count of the file descriptors pointed to it, so it knows when the last one was deleted), then if the last file description pointed to an in memory i node is closed, the in memory i node is closed. Doesn’t have to <code class="highlighter-rouge">close</code> actually, it will automatically close once the process terminated.</p> </li> <li> <p>User Buffering: Not really much to say, BUFIO will accelerate the provess.</p> </li> <li> <p><code class="highlighter-rouge">lseek()</code>: set the file offset, return the result offset</p> <ul> <li>whence: SEEK_SET -&gt; set to pos, SEEK_CUR -&gt; set to current + pos (can be positive, 0, or negative), SEEK_END -&gt; set to file size + pos</li> <li>resulting offset must be non-negative</li> </ul> </li> <li> <p><code class="highlighter-rouge">pread() pwrite()</code>: it is the <code class="highlighter-rouge">read</code> and <code class="highlighter-rouge">write</code> ignoring the offset, don use and don’t set .</p> <ul> <li>will solve the problem of another process changing the offset between <code class="highlighter-rouge">lseek()</code> and <code class="highlighter-rouge">read, write</code></li> </ul> </li> <li> <p><code class="highlighter-rouge">readv() writev()</code>: can write contagious data to the file in different places at once, need to set up the <code class="highlighter-rouge">*iov</code> to make it contain a pointer to data and the size of the data. Save some time by avoiding multiple system calls.</p> </li> <li> <p>Synchronized I/O:</p> <ul> <li>Synchronized vs. Synchronous: Normally UNIX is un-synchronized and synchronous <ul> <li>Synchronized means the <code class="highlighter-rouge">write()</code> doesn’t return until the actual data is written on the disk;</li> <li>Synchronous means the <code class="highlighter-rouge">read()</code> doesn’t return until data is available and <code class="highlighter-rouge">write()</code> has at least put the data in kernel buffer, and actually writes to disk if it is also Synchronized.</li> </ul> </li> <li>Buffer-flushing System Calls: <ul> <li><code class="highlighter-rouge">sync()</code> tell the kernel to schedule flushing all buffer written so far, but it returns once it is scheduled. Used when kernel is shut down or a portable device is unmounted.</li> <li><code class="highlighter-rouge">fsync()</code>flushes buffer specified by <code class="highlighter-rouge">fd</code> and didn’t return until buffer is indeed flushed, if the System is set to be synchronized.</li> <li><code class="highlighter-rouge">fdatasync()</code>is faster than <code class="highlighter-rouge">fsync()</code> as it only flushes the real data, not the controlling data like modification time.</li> <li>open flags for synchronization: <ul> <li>O_SYNC: an implicit <code class="highlighter-rouge">fsync()</code> for every write;</li> <li>O_DSYNC: an implicit <code class="highlighter-rouge">fdatasync()</code> for every write</li> <li>O_RSYNC: update the access time in a synchronized manner.</li> </ul> </li> </ul> </li> </ul> </li> <li> <p><code class="highlighter-rouge">truncate()</code> and <code class="highlighter-rouge">ftruncate()</code>: <code class="highlighter-rouge">truncate()</code> with path name, and <code class="highlighter-rouge">ftruncate()</code> with fd to shrink the file.</p> </li> </ul> <h3 id="process-and-threads"><span name="process-and-threads">Process and Threads</span></h3> <ul> <li> <p>Environment:</p> <ul> <li>when a UNIX program runs, it receives two groups of data, the arguments and the environment, which are both array of character pointer to NUL-terminated strings.</li> <li>global variable <code class="highlighter-rouge">environ</code> has the form name = value; can use <code class="highlighter-rouge">getenv()</code> to get the corresponding envrion; use <code class="highlighter-rouge">putenv()</code> <code class="highlighter-rouge">setenv()</code> and <code class="highlighter-rouge">unsetenv()</code> to adjust environment variables</li> </ul> </li> <li> <p><code class="highlighter-rouge">exec()</code> system call:<code class="highlighter-rouge">exec()</code> system call reinitialized a process from a designated program, always used with <code class="highlighter-rouge">fork()</code></p> <ul> <li>Program, processes, and threads: <ul> <li>Program, collection of instruction and data that is kept in a regular file on disk, marked executable in i-node; contents obey rules established by the kernel; program into text-file -&gt; object file with machine-language translation; linker is used to bind object file with libraries</li> <li>Process, is created to run a program; contains three segments: instruction seg, user data seg, system data seg (include current dic, open file des, accumulated CPU time);</li> <li>Threads, are tracked by kernel: separate flow of control through instructions, start with one thread, unless execute special system call to create another;</li> <li>There is no functional relationship between processes initialized from the same program ( process can not detect shared instruction seg); strong functional replationship between threads in the same process</li> <li>Process has inheritance, threads are equal ( all threads have equal access to all data and resources, not copy)</li> </ul> </li> </ul> </li> <li> <p><code class="highlighter-rouge">fork()</code> create a new process by copying the system-data segment from the old process, child receives a 0 on success return and parent receives the process-ID of the child. Then the child usually does an exec and the parent either waits or do something else.</p> <ul> <li>Several things that are not inherited by the child process: <ul> <li>pid (废话）</li> <li>if the parent is multiprocess, only the one calling fork() exists on child</li> <li>same file description but different file descriptor</li> <li>execution time</li> </ul> </li> </ul> </li> <li> <p><code class="highlighter-rouge">exit()</code>: same as returning a value from main and call <code class="highlighter-rouge">exit()</code> on that argument</p> <ul> <li>_exit and _Exit one is from UNIX, the other from standard C</li> <li><code class="highlighter-rouge">exit()</code> a higher level than <code class="highlighter-rouge">_exit</code> as it does some sort of clean up, call function registered atexit, and do a flush of I/O buffer.</li> <li>usually call <code class="highlighter-rouge">_exit</code> in a child process that hasn’t done an <code class="highlighter-rouge">exec</code></li> <li>upon termination: all open file descriptors are closed, all child processes now have a special system process as parent</li> </ul> </li> <li> <p><code class="highlighter-rouge">wait(),waitpid(),waitid()</code>: waits for a child process</p> <ul> <li> <p><code class="highlighter-rouge">waitpid()</code>:</p> <ul> <li> <p>pid argument:</p> <ul> <li> <blockquote> <p>0: wait for the specific child process with pid</p> </blockquote> </li> <li> <p>-1: wait for any child process</p> </li> <li> <p>0: wait for any child process in the same process group as the calling process</p> </li> <li>&lt; -1: wait for any child process in the process group whose process-group id is -pid</li> </ul> </li> <li> <p>only direct child created by <code class="highlighter-rouge">fork()</code> can be waited for, normally a process should wait for every child it created, or the terminated child process may exist in system as zombie until parents terminated</p> </li> <li> <p>a child changes status is waitable, can cause at most one return from waitpid</p> </li> </ul> </li> <li> <p><code class="highlighter-rouge">wait()</code> is a short hand for <code class="highlighter-rouge">waitpid</code> with pid = -1</p> </li> <li> <p><code class="highlighter-rouge">waitid()</code> get the status of a process back and keep it waitable</p> </li> </ul> </li> <li> <p>Setting User and Group IDs and Process IDs: Kernel keeps the saved id that were set by last <code class="highlighter-rouge">exec()</code>, no ordinary process can explicitly change real user ID or saved ID, except <code class="highlighter-rouge">exec</code> can change saved id; ordinary process can change effective ID to real or saved ID, superuser can change real and effective ID to any value, saved ID changes with the real ID if a superuser changes it.</p> <ul> <li>use <code class="highlighter-rouge">seteuid, setegid</code> superuser can also use <code class="highlighter-rouge">setuid, setgid</code></li> <li><code class="highlighter-rouge">getpid()</code> and <code class="highlighter-rouge">getppid()</code> can get process ID or process ID of parent.</li> </ul> </li> </ul> <h3 id="-interprocess-communication"><span name="interprocess-communication"> Interprocess Communication</span></h3> <ul> <li> <p>Pipe: unnamed Pipe</p> <ul> <li>create: <code class="highlighter-rouge">pipe</code> system call, returns an array of 2 file descriptor, representing a communication channel, writing to pfd[1] to put data in pipe, and read from pfd[0] to get it out; use <code class="highlighter-rouge">pipebuf</code> when multiple processes are writing to the same pipe, so that data written is atomic (if bytes smaller or equal to buf size);</li> <li>Pipe behavior: <ul> <li><code class="highlighter-rouge">write</code>: data written to a pipe is sequenced in order of arrival, and <code class="highlighter-rouge">write</code> will block if not enough room until enough data was removed by <code class="highlighter-rouge">read</code>. There is no partial write. If amount is larger than PIPE_BUF, partial write is possible.</li> <li><code class="highlighter-rouge">read</code> : data read from pipe is in order of arrival, and can not be reread or put back. <code class="highlighter-rouge">read</code> will block if there is no data for reading, or return 0 if all <code class="highlighter-rouge">write</code> ends are closed, byte count is the most byte can be read at once .</li> <li><code class="highlighter-rouge">close</code> : if frees up the file descriptor for reuse, and if all writing end are closed, reader will reach EOF. If all reading ends closed, <code class="highlighter-rouge">write</code> returns an error.</li> <li><code class="highlighter-rouge">fstat</code> and <code class="highlighter-rouge">lseek</code> are not useful</li> <li><code class="highlighter-rouge">dup</code> and <code class="highlighter-rouge">dup2</code> : duplicate a new file descriptor that points to the same file and shared the same file description, <code class="highlighter-rouge">dup2</code> can specify which fd to use, and will close it if necessary.</li> </ul> </li> <li>General Guidance: create a pipe -&gt; fork the reading child -&gt; close the writing end and do other preparation in child process -&gt; execute the child program in child process -&gt; close the reading end in parent process -&gt; if using a second child to write, create it and make preparation, if parent is writing, just write.</li> </ul> </li> <li> <p>FIFO or Named Pipe: FIFO combines regular files and pipes, it has name and can be opened by any process with the right permission, so unrelated process can communicate over a FIFO. Always opened for reading and waiting for a different process to open it for writing, once created, it follows the same pipe behavior, vice versa. O_NONBLOCK flag can be used read will succeed and write will fail if no reader is opened, this prevent putting data in the FIFO</p> <ul> <li>create: <code class="highlighter-rouge">mkfifo</code>: the PERM is used to set the new file permission, once it is created, it behaves like a pipe. Mostly useful to pass data between server and client.</li> <li>critique: single FIFO can not have multiple read ends, data has to be copied back and forth causing too many system calls;</li> </ul> </li> <li> <p>System V IPC: older set of semaphores, message queue and shared memory, newer is POSIX IPC</p> <ul> <li>These three objects are not files, but mechanism with unique naming. Principles: <ul> <li>exist only within a single machine, can not communicate through network</li> <li>life time is the same as kernel</li> <li>access through an integer key that is invariant for the whole life time , any process know this key can open the object</li> </ul> </li> <li>use system calls : (msg, sem, shm) + (get, ctl); also msgsnd, msgrcv and semop shmat, smdt.</li> <li><code class="highlighter-rouge">ftok</code>can generate keys from pathname, specified by the id parameter; two different paths in the same file system will generate different keys</li> <li>Ownership and Permission: use the struct <code class="highlighter-rouge">ipc_perm</code> for permission that specify owner and creator user and group ID</li> <li>utilities in command line: use ipcs for displaying info, ipcrm to remove specified object</li> </ul> </li> <li> <p>System V Message Queue:</p> <ul> <li> <p>System calls:</p> <ul> <li> <p><code class="highlighter-rouge">msgget</code>:IPC_CREAT and IPC_EXCL to set flags for creating or failing if exists. A key IPC_PRIVATE will guarantee a unique key</p> </li> <li> <p><code class="highlighter-rouge">msgctl</code>: take the struct msqid_ds to control the existing queue (IPC_RMID to remove, IPC_STAT to get info IPC_SET to set id, mode and permission.</p> </li> <li> <p><code class="highlighter-rouge">msgsnd</code> and <code class="highlighter-rouge">msgrcv</code>: with a struct <code class="highlighter-rouge">msg</code> that can be user-defined, and a type parameter:</p> <ul> <li> <p>= 0: receive the first message, regardless type</p> </li> <li> <blockquote> <p>0 : receive first message of specified type</p> </blockquote> </li> <li> <p>&lt; 0: get first message with type lower or equal the absolute value of type</p> </li> <li> <p>if don’t care, use 1 when send, and 0 when receive</p> </li> <li><code class="highlighter-rouge">msgsize</code> always set to <code class="highlighter-rouge">sizeof(msg.data)</code></li> </ul> </li> </ul> </li> <li> <p>Limits: There are limits on the number of message, size of total message in a queue, and size of message, total number of queues in a system</p> </li> </ul> </li> <li> <p>Semaphores: used as a counter to prevent two or more processes from accessing the shared resource at the same time</p> <ul> <li> <p>use <code class="highlighter-rouge">semwait</code> to decrease counter and <code class="highlighter-rouge">sempost</code> to increase won’t work well:</p> <ul> <li>the semaphore may not be shared by processes</li> <li>if kernel interrupt it, tt is not executed atomically <ul> <li>will cause inefficient CPU use if <code class="highlighter-rouge">semwait</code> wait on counter 0</li> </ul> </li> </ul> </li> <li> <p>System V semaphore:</p> <ul> <li><code class="highlighter-rouge">semget</code>get semaphore identifier but doesn’t initialize it, use <code class="highlighter-rouge">semctl</code> to set the counter</li> <li>Process or thread creates the semaphore also calls semctl to initialize it, and then use <code class="highlighter-rouge">sem_op</code> to set the sem_otime which is initialized as 0, so other process will wait until the sem_otime becomes non-zero (so they know it is initialized)</li> </ul> </li> <li> <p><code class="highlighter-rouge">semop</code>: operate on semaphore with struct <code class="highlighter-rouge">sembuf</code>,</p> <ul> <li> <p>each <code class="highlighter-rouge">sem_op</code> in <code class="highlighter-rouge">sembuf</code> can be positive, zero, or negative:</p> <ul> <li> <blockquote> <p>0 increment semaphore value</p> </blockquote> </li> <li> <p>&lt;0 decrease semaphore value</p> </li> <li>0 block until value get to 0</li> </ul> </li> <li> <p>all <code class="highlighter-rouge">semop</code> operation is atomic, and function doesn’t return until everything is done, blocking can be prevented with IPC_NOWAIT flag</p> </li> <li> <p>adjustment is stored for any increments or decrements, so op can be undone with IPC_UNDO flag</p> </li> </ul> </li> </ul> </li> <li> <p>Share Memory:</p> <ul> <li>System V shared memory: <ul> <li><code class="highlighter-rouge">shmget shmctl shmat shmdt</code>: used to get attach detach and control the shared memory, <code class="highlighter-rouge">shmget</code> will get you the identifier and is used in <code class="highlighter-rouge">shmctl</code>, but <code class="highlighter-rouge">shmat</code> gives you the pointer which should be passed to <code class="highlighter-rouge">shmdt</code></li> <li>Shared memory and Semaphore: You can not share memory between two processes without some form of semaphore control, can not assume the pointer is atomic. Procedures:</li> <li>The child assigned *p to local memory with the semaphore locked and then was free to use the local memory with the semaphore unlocked. <ul> <li>Similarly, the parent used a local variable in the for loop, locking the semaphore only to access the shared memory.</li> <li>Initially, the semaphore is locked (zero value), so the parent is free to initialize the shared memory to zero. Then it calls SimpleSemPost to get things moving. It’s OK if the child accesses the shared memory at that point. This version then can be run repeatedly since it initializes the segment each time it’s run.</li> <li>We remove the semaphore at the start of each run so that it will start with zero.</li> </ul> </li> </ul> </li> </ul> </li> <li> <p>Signal: a notification that an event has occurred, it’s life cycle is that when the event it’s associated occurs and generates it until it is delivered and the action has been taken.</p> <ul> <li> <p>3 possible actions are: SIG_DFL for default, SIG_IGN for ignore, and user specified action, which is process-wide;</p> <ul> <li> <p><code class="highlighter-rouge">sigaction</code>: set signal action with struct <code class="highlighter-rouge">sigaction</code>, that can have SIG_DFL, SIG_IGN or a function pointer</p> </li> <li> <p><code class="highlighter-rouge">kill killpg pthread_kill abort riase</code> to generate signalst to pid:</p> <ul> <li> <blockquote> <p>0 whosse process is pid</p> </blockquote> </li> <li> <p>0 whose procexx group is the same as the sending-process</p> </li> <li> <p>&lt; -1 process-group id is absolute of pid</p> </li> <li>-1 all processes of sender has permission</li> </ul> </li> <li> <p>effect of <code class="highlighter-rouge">fork pthread_create exec</code> on signal:</p> <ol> <li>Signal actions: After a fork, the child inherits all signal actions. After an exec, signals set to SIG_DFL remain that way; signals set to SIG_IGN remain that way, except for SIGCHLD, which may be set to SIG_IGN or SIG_DFL, as the implementation chooses; caught signals are set to SIG_DFL. As all actions are process-wide, pthread_create has no effect.</li> <li>Signal mask: Inherited from the forking thread after a fork; stays the same as the execing thread after an exec; copied to the new thread from the creating thread after a pthread_create.</li> <li>Pending signals: Cleared after a fork; same as the execing thread after an exec; cleared after a pthread_create.</li> </ol> </li> </ul> </li> <li> <p>A signal mask is a collection of all pending/ blocking signals of this process</p> <ul> <li>Managing: <code class="highlighter-rouge">sigempset sigfillset sigaddset sigdelset sigismember</code> to test, set, or clear a sigmask bit. Start with <code class="highlighter-rouge">sigempset </code>or <code class="highlighter-rouge">sigfillset</code> and do other operation on the mask</li> <li>Set: there is only one sigmask at a time for one thread and it can be set by using <code class="highlighter-rouge">pthread_sigmask</code>, taking parameters <code class="highlighter-rouge">set</code> and <code class="highlighter-rouge">how</code>. SIG_BLOCK add the set, SIG_UNBLOCK remove the set, and SIG_SET set the mask to set; SIGKILL and SIGSTOP can not be blocked. If only one thread for a process, can use <code class="highlighter-rouge">sigprocmask</code> that use errno instead of returning error code.</li> </ul> </li> <li> <p>The delivery of a nonignored signal will cause the system call to be interrupted, if the action was to terminate, the interrupted system call is never resumed, if it is to stop the process, it will pick it up whenever it is left. only system calls that blocks – waiting for unpredictable result can be interrupted.</p> </li> <li> <p>Deprecated Signal System Call</p> <ul> <li>classic way to set sigaction <code class="highlighter-rouge">signal</code>: new action parameter looks like : <code class="highlighter-rouge">void (*act)(int)</code>, could be a pointer to a function taking an integer argument</li> <li>Upon delivery, the sigaction is reset to SIG_DFT, need to call <code class="highlighter-rouge">signal</code> again</li> <li>The delivered signal is not blocked, so the second arrival may terminate the process</li> </ul> </li> <li> <p>Global Jumps: normally a function returns by executing return statement but can be redirected by jmp:</p> <ul> <li><code class="highlighter-rouge">setjmp</code> with jmp_buf that hold a saved location info, return 0 if called directlym or return val set by long jmp. First, setjmp location with location info you need, and no matter how deep nested you are in a function, use <code class="highlighter-rouge">longjmp</code> to jum to arbitrary location</li> <li>To force sigmask beign restored, use <code class="highlighter-rouge">sigsetjmp</code> and <code class="highlighter-rouge">siglongjmp</code>, the sigmask restored is the one that is called when <code class="highlighter-rouge">sigsetjmp</code></li> <li>force the sigmask to be reset, use <code class="highlighter-rouge">_setjmp</code> and <code class="highlighter-rouge">_longjmp</code></li> </ul> </li> <li> <p>Clocks and Timers</p> <ul> <li><code class="highlighter-rouge">alarm</code>: every process has one alarm set for the system call, and SIGALARM is sent when the alarm goes off, a child inherits its parent’s alarm clock but the actual clock is not shared. The system call <code class="highlighter-rouge">alaram()</code> set the second given by sec and return the old value, if sec is 0 the alarm is turned off (eg: call a read, and set an alarm for 5 secs, if the read is longer than 5 sec, it will be blocked, but if it is shorter, remember to turn off the alarm, or it will block something else)</li> <li><code class="highlighter-rouge">sleep</code>: blocks a thread for specific time</li> </ul> </li> </ul> </li> </ul> <hr> <div class="row"> <div class="col-md-6"> <h5 style="display: inline;">Tags:</h5> <button class="btn btn-white btn-xs" type="button">UNIX</button> <button class="btn btn-white btn-xs" type="button">School</button> </div> <div class="col-md-6"> <div class="small text-right"> <div> </div> </div> </div> </div> <br> <div class="row"> <div class="col-lg-12"> <!-- donate --> <br> <!-- share --> <div class="a2a_kit a2a_kit_size_32 a2a_default_style"> <a class="a2a_dd" href="https://www.addtoany.com/share"></a> <a class="a2a_button_facebook"></a> <a class="a2a_button_twitter"></a> <a class="a2a_button_google_plus"></a> <a class="a2a_button_linkedin"></a> <a class="a2a_button_email"></a> <a class="a2a_button_wechat"></a> <a class="a2a_button_sina_weibo"></a> <a class="a2a_button_pocket"></a> </div> <script> var a2a_config = a2a_config || {}; a2a_config.color_main = "D7E5ED"; a2a_config.color_border = "AECADB"; a2a_config.color_link_text = "333333"; a2a_config.color_link_text_hover = "333333"; </script> <script async src="https://static.addtoany.com/menu/page.js"></script> <br> <!-- comment --> </div> </div> </div> </div> </div> </div> </div> <!-- Google analytics --> <!-- GrowingIO --> </body> </html>
